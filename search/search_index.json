{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Lund University Modular Inversion Algorithm (LUMIA) is a python package for performing atmospheric transport inversions. The release 2020.8 is described in https://www.geosci-model-dev-discuss.net/gmd-2019-227/ can be downloaded here , however, we recommend instead getting the latest commit from github This documentation focuses on an updated release (== NOTE: this documentation is being revised at the very moment. The text in this page refers to the \"master\" branch, not to the \"default\" one.==). Installation The installation instructions are described in further details in the README file. In short: 1. Create a python virtual environment, using your favourite environment manager (e.g., conda) 2. Git clone the lumia source code in a clean folder 3. Install LUMIA as a python package in your python virtual environment, using pip 4. Start working! Documentation Theoretical summary LUMIA is (primarily) a library for performing atmospheric inversions: Observations of the atmospheric composition are used to improve a prior estimate of the emissions (or fluxes) of one (or several) atmospheric tracer (e.g CO \\(_2\\) ). The inversion relies on an atmospheric chemistry-transport model (CTM) to link fluxes of a tracer in and out of the atmosphere with observed atmospheric concentration. This can be formalized as \\[y + \\varepsilon_{y} = H(x) + \\varepsilon_{H}\\] where \\(y\\) is an ensemble of observations, \\(H\\) is a CTM, and \\(x\\) is a vector containing parameters controlling the CTM (i.e. x is the control vector ). The uncertainty terms \\(\\varepsilon_{y}\\) and \\(\\varepsilon_{H}\\) represent respectively the measurement error and the model error. The aim of the inversion is to determine the control vector \\(x\\) that leads to the optimal fit of the model \\(H\\) to the observations \\(y\\) . This is formalized as finding the vector \\(x\\) that minimises the cost function \\[J(x) = \\frac{1}{2}\\left(x-x_b\\right)^TB^{-1}\\left(x-x_b\\right) + \\frac{1}{2}\\left(H(x) - y\\right)^TR^{-1}\\left(H(x) - y\\right)\\] where \\(x_b\\) a prior estimate of the control vector \\(x\\) (that we are trying to determine). The error covariance matrices \\(B\\) and \\(R\\) contain respectively the estimated uncertainties on \\(x_b\\) and \\(y - H(x)\\) . The optimal control vector \\(\\hat{x}\\) is determined using an iterative conjugate gradient approach. While the aim of the inversion is typically to estimate the emissions of a tracer, the control vector \\(x\\) rarely consists (directly) of the emissions: it can for instance contain scaling factor or offsets, at a lower resolution than the emission themselves, it may contain only a subset of the emissions, it can also include additional terms such as an estimate of the boundary condition, bias correction terms, etc. \\[ E = M(x) \\] Implementation LUMIA implement the various components of the aforedescribed inversion approach as semi independent python modules: - The lumia.observations module implements the observation vector ( \\(y\\) ), the corresponding uncertainties ( \\(R\\) ); - The lumia.models module implements the CTM \\(H\\) . It also contains two sub-modules: - The lumia.prior module implements the prior control vector \\(x_b\\) and its uncertainty matrix \\(B\\) ; - The lumia.optimizer module implements the optimization algorithm; - The lumia.data module implements the emissions ( \\(E\\) ) themselves; - The lumia.mapping module implement the mapping operator ( \\(M\\) ), that is used to convert between model data and control vector. Most of these modules can be used independently. For instance, the lumia.observations defines an Observation class that can be used to read, write and analyze observation files used in LUMIA (including LUMIA results).","title":"Home"},{"location":"#installation","text":"The installation instructions are described in further details in the README file. In short: 1. Create a python virtual environment, using your favourite environment manager (e.g., conda) 2. Git clone the lumia source code in a clean folder 3. Install LUMIA as a python package in your python virtual environment, using pip 4. Start working!","title":"Installation"},{"location":"#documentation","text":"","title":"Documentation"},{"location":"#theoretical-summary","text":"LUMIA is (primarily) a library for performing atmospheric inversions: Observations of the atmospheric composition are used to improve a prior estimate of the emissions (or fluxes) of one (or several) atmospheric tracer (e.g CO \\(_2\\) ). The inversion relies on an atmospheric chemistry-transport model (CTM) to link fluxes of a tracer in and out of the atmosphere with observed atmospheric concentration. This can be formalized as \\[y + \\varepsilon_{y} = H(x) + \\varepsilon_{H}\\] where \\(y\\) is an ensemble of observations, \\(H\\) is a CTM, and \\(x\\) is a vector containing parameters controlling the CTM (i.e. x is the control vector ). The uncertainty terms \\(\\varepsilon_{y}\\) and \\(\\varepsilon_{H}\\) represent respectively the measurement error and the model error. The aim of the inversion is to determine the control vector \\(x\\) that leads to the optimal fit of the model \\(H\\) to the observations \\(y\\) . This is formalized as finding the vector \\(x\\) that minimises the cost function \\[J(x) = \\frac{1}{2}\\left(x-x_b\\right)^TB^{-1}\\left(x-x_b\\right) + \\frac{1}{2}\\left(H(x) - y\\right)^TR^{-1}\\left(H(x) - y\\right)\\] where \\(x_b\\) a prior estimate of the control vector \\(x\\) (that we are trying to determine). The error covariance matrices \\(B\\) and \\(R\\) contain respectively the estimated uncertainties on \\(x_b\\) and \\(y - H(x)\\) . The optimal control vector \\(\\hat{x}\\) is determined using an iterative conjugate gradient approach. While the aim of the inversion is typically to estimate the emissions of a tracer, the control vector \\(x\\) rarely consists (directly) of the emissions: it can for instance contain scaling factor or offsets, at a lower resolution than the emission themselves, it may contain only a subset of the emissions, it can also include additional terms such as an estimate of the boundary condition, bias correction terms, etc. \\[ E = M(x) \\]","title":"Theoretical summary"},{"location":"#implementation","text":"LUMIA implement the various components of the aforedescribed inversion approach as semi independent python modules: - The lumia.observations module implements the observation vector ( \\(y\\) ), the corresponding uncertainties ( \\(R\\) ); - The lumia.models module implements the CTM \\(H\\) . It also contains two sub-modules: - The lumia.prior module implements the prior control vector \\(x_b\\) and its uncertainty matrix \\(B\\) ; - The lumia.optimizer module implements the optimization algorithm; - The lumia.data module implements the emissions ( \\(E\\) ) themselves; - The lumia.mapping module implement the mapping operator ( \\(M\\) ), that is used to convert between model data and control vector. Most of these modules can be used independently. For instance, the lumia.observations defines an Observation class that can be used to read, write and analyze observation files used in LUMIA (including LUMIA results).","title":"Implementation"},{"location":"installation/","text":"Package structure and recommended installation Package structure LUMIA is distributed as a python package. The (simplified) folder structure is the following: - docs : this documentation - lumia : the lumia python package (accessible via an import lumia in python), which contains all the optimization-related code - transport : the transport python package (accessible via import transport ), which is the pseudo-transport model used in LUMIA - gridtools.py : source code for the gridtools package (accessible via import gridtools ), which contains some utilities to handle spatial grids. - run : the run folder contains some example scripts using LUMIA. It is also the recommended place to put your own scripts. By default, files in that folder are excluded from the git repository. At the root of the git repository, you will also find the following files: - mkdocs.yml : this file defines the structure of the online documentation - Makefile : the Makefile contains a few recepies for installing and configuring lumia - setup.py : this is the file that enables installing lumia as a python package. Do not use it directly (see installation notes below). - requirements.txt : this file contains the list of python packages required by lumia. Installation We recommend installing LUMIA in a dedicated python virtual environment. We suggest using conda for this (https://docs.conda.io/en/latest/) as it will facilitate installing packages that are not purely python-based (e.g. cartopy , xesmf , etc.). However, other tools (including the standard venv ) should work as well. Creation of a conda environment: Dowload and install anaconda/miniconda if needed: bash mkdir -p ~/miniconda3 wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 rm -rf ~/miniconda3/miniconda.sh Activate your conda installation: conda init bash Create a virtual environment: conda create -n my_env python=3.11 (we recommend using the latest python version available). Activate the environment: conda activate my_env Installing lumia If not already done, clone the lumia git repository: git clone ... my_project cd my_project Install the dependencies: with conda: conda install --file requirements.txt with pip: pip install -r requirements.txt Install lumia itself: pip install -e .","title":"Installation"},{"location":"installation/#package-structure-and-recommended-installation","text":"","title":"Package structure and recommended installation"},{"location":"installation/#package-structure","text":"LUMIA is distributed as a python package. The (simplified) folder structure is the following: - docs : this documentation - lumia : the lumia python package (accessible via an import lumia in python), which contains all the optimization-related code - transport : the transport python package (accessible via import transport ), which is the pseudo-transport model used in LUMIA - gridtools.py : source code for the gridtools package (accessible via import gridtools ), which contains some utilities to handle spatial grids. - run : the run folder contains some example scripts using LUMIA. It is also the recommended place to put your own scripts. By default, files in that folder are excluded from the git repository. At the root of the git repository, you will also find the following files: - mkdocs.yml : this file defines the structure of the online documentation - Makefile : the Makefile contains a few recepies for installing and configuring lumia - setup.py : this is the file that enables installing lumia as a python package. Do not use it directly (see installation notes below). - requirements.txt : this file contains the list of python packages required by lumia.","title":"Package structure"},{"location":"installation/#installation","text":"We recommend installing LUMIA in a dedicated python virtual environment. We suggest using conda for this (https://docs.conda.io/en/latest/) as it will facilitate installing packages that are not purely python-based (e.g. cartopy , xesmf , etc.). However, other tools (including the standard venv ) should work as well.","title":"Installation"},{"location":"installation/#creation-of-a-conda-environment","text":"Dowload and install anaconda/miniconda if needed: bash mkdir -p ~/miniconda3 wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 rm -rf ~/miniconda3/miniconda.sh Activate your conda installation: conda init bash Create a virtual environment: conda create -n my_env python=3.11 (we recommend using the latest python version available). Activate the environment: conda activate my_env","title":"Creation of a conda environment:"},{"location":"installation/#installing-lumia","text":"If not already done, clone the lumia git repository: git clone ... my_project cd my_project Install the dependencies: with conda: conda install --file requirements.txt with pip: pip install -r requirements.txt Install lumia itself: pip install -e .","title":"Installing lumia"},{"location":"observations/","text":"Observation This module needs revision, the doc below is for now a placeholder Observation module(s) The observations are stored in a lumia.obsdb.obsdb object ( lumia/obsdb/ init .py ). Several derived classes exist, or can be constructed by the user to extend its basic features. Object structure: The obsdb class has two main data attributes: observations is a DataFrame object (from the pandas library), and contains a list of observations and their characteristics (time, mixing ratio, uncertainties, background concentration, etc.) sites is another DataFrame , and contains information common to groups of observations (e.g. coordinates)","title":"Observation"},{"location":"observations/#observation","text":"This module needs revision, the doc below is for now a placeholder","title":"Observation"},{"location":"observations/#observation-modules","text":"The observations are stored in a lumia.obsdb.obsdb object ( lumia/obsdb/ init .py ). Several derived classes exist, or can be constructed by the user to extend its basic features.","title":"Observation module(s)"},{"location":"observations/#object-structure","text":"The obsdb class has two main data attributes: observations is a DataFrame object (from the pandas library), and contains a list of observations and their characteristics (time, mixing ratio, uncertainties, background concentration, etc.) sites is another DataFrame , and contains information common to groups of observations (e.g. coordinates)","title":"Object structure:"},{"location":"settings/","text":"Configuration file The settings are contained in a configuration file in yaml format. The file contains six major sections: the run section, which contains general simulation settings (domain, resolution, etc.) the emissions section contains all settings needed to construct the file containing the surface fluxes the observations section contains all settings needed to handle the observations (obs file, units, uncertainties, etc.) the optimize section contains settings specific to the inversion (which category needs to be optimized, with which uncertainties, etc.) the model section contains settings of the transport model the minimizer section contains settings of the conjugate gradient minimizer Additional sections may be defined for convenience. The values in this page are those used for the tutorial run section General settings (simulation extent and resolution, paths, etc.) run: start : 2018-01-01 end : 2019-01-01 timestep : 1h domain : eurocom025x025 grid : ${Grid:{lon0:-15, lat0:33, lon1:35, lat1:73, dlon:.5, dlat:.5}} tracers : co2 paths : data : data output : output footprints : footprints temp : temp start and end (time boundaries of the simulation) can be in any format supported by pandas.Timestamp . timestep can be anything supported by pandas.tseries.frequencies.to_offset . The grid key defines an instance of gridtools.Grid . The syntax is ${Grid:value} , with value a python dictionary containing keywords passed to gridtools.Grid . emissions section: The section contains keys needed to construct the emissions file. There needs to be one subsection for each tracer (only one \"co2\" tracer in this example), and an emissions.tracers key is also necessary. The emission file for the simulation is constructed from annual, category-specific, pre-processed emission files. The keys define the naming pattern for these files: the files are in data/fluxes/nc/eurocom025x025/1h the files for category biosphere are named following the pattern flux_co2.EDGARv4.3_BP2019.%Y.nc emissions : tracers : ${run.tracers} co2 : region : ${run.grid} interval : ${run.timestep} categories : fossil : EDGARv4.3_BP2019 biosphere : LPJ-GUESS_verify prefix : flux_co2. path : ${run.paths.data}/fluxes/nc/${run.domain}/{run.timestep}/ observations section: The section contains keys needed to read and process the observation database. In this tutorial, it just points to the right observation file, but further settings are possible, to restrict the time period, setup the uncertainties, etc. These settings are read in two places: directly in the relevant obsdb module ( lumia.obsdb.InversionDb.obsdb class) in a pre-processing step, e.g. in the lumia.ui.setup_observations method. See the in-line documentation of these two modules for further info observations : file : path : doc/observations/obs_example.tar.gz optimize section This section contains the keys that define the inversion problem. It contains two large subsection: one \"emissions\" subsection, which contains settings related to the state vector and its uncertainty matrix (structure of the uncertainty, number of optimized categories, resolution of the optimization, etc.) one \"observations\" subsection, which defines the way observation uncertainties are treated: optimize : emissions : co2 : biosphere : annual_uncertainty : 0.45 PgC spatial_correlation : 500-g temporal_correlation : 30D npoints : 2500 optimization_interval : 7d observations : co2 : uncertainty : type : dyn freq : 7d Here, the emissions will be optimized for the biosphere category of the co2 tracer. The total uncertainty is set to 0.45 PgC ( annual_uncertainty ), with correlations decaying spatially ( spatial_correlation ) following a 500 km Gaussian function, and temporally ( temporal_correlation ) following a 30 days exponential function (see sect 3.5.1 in https://gmd.copernicus.org/articles/14/3383/2021/ ). The inversion solves for 2500 cluster of pixels ( npoints ) each seven days ( optimization_interval ). With observations.co2.uncertainty.type set to dyn , the observation uncertainties are determined based on the quality of the fit of the short term (< 7 days) variability of the modelled concentration to the observed concentrations (see setup_uncertainties method). congrad section: This short section contains settings for the conjugate gradient minimizer. The main relevant user-setting is max_number_of_iterations (set to a lower value to speed things up, set to > 50 for scientific results): congrad : max_number_of_iterations : 80 communication_file : ${run.paths.temp}/congrad.nc executable : ${lumia:src/congrad/congrad.exe} model section This section contains settings for the interface between lumia and the transport model (i.e. lumia/obsoperator ) model : transport : exec : ${lumia:transport/multitracer.py} serial : False output : steps : ['apri', 'apos'] path : ${run.paths} Note the syntax of the model.transport.exec key: ${lumia:path} points to a path relative to the installation path of the lumia python module.","title":"Settings"},{"location":"settings/#configuration-file","text":"The settings are contained in a configuration file in yaml format. The file contains six major sections: the run section, which contains general simulation settings (domain, resolution, etc.) the emissions section contains all settings needed to construct the file containing the surface fluxes the observations section contains all settings needed to handle the observations (obs file, units, uncertainties, etc.) the optimize section contains settings specific to the inversion (which category needs to be optimized, with which uncertainties, etc.) the model section contains settings of the transport model the minimizer section contains settings of the conjugate gradient minimizer Additional sections may be defined for convenience. The values in this page are those used for the tutorial","title":"Configuration file"},{"location":"settings/#run-section","text":"General settings (simulation extent and resolution, paths, etc.) run: start : 2018-01-01 end : 2019-01-01 timestep : 1h domain : eurocom025x025 grid : ${Grid:{lon0:-15, lat0:33, lon1:35, lat1:73, dlon:.5, dlat:.5}} tracers : co2 paths : data : data output : output footprints : footprints temp : temp start and end (time boundaries of the simulation) can be in any format supported by pandas.Timestamp . timestep can be anything supported by pandas.tseries.frequencies.to_offset . The grid key defines an instance of gridtools.Grid . The syntax is ${Grid:value} , with value a python dictionary containing keywords passed to gridtools.Grid .","title":"run section"},{"location":"settings/#emissions-section","text":"The section contains keys needed to construct the emissions file. There needs to be one subsection for each tracer (only one \"co2\" tracer in this example), and an emissions.tracers key is also necessary. The emission file for the simulation is constructed from annual, category-specific, pre-processed emission files. The keys define the naming pattern for these files: the files are in data/fluxes/nc/eurocom025x025/1h the files for category biosphere are named following the pattern flux_co2.EDGARv4.3_BP2019.%Y.nc emissions : tracers : ${run.tracers} co2 : region : ${run.grid} interval : ${run.timestep} categories : fossil : EDGARv4.3_BP2019 biosphere : LPJ-GUESS_verify prefix : flux_co2. path : ${run.paths.data}/fluxes/nc/${run.domain}/{run.timestep}/","title":"emissions section:"},{"location":"settings/#observations-section","text":"The section contains keys needed to read and process the observation database. In this tutorial, it just points to the right observation file, but further settings are possible, to restrict the time period, setup the uncertainties, etc. These settings are read in two places: directly in the relevant obsdb module ( lumia.obsdb.InversionDb.obsdb class) in a pre-processing step, e.g. in the lumia.ui.setup_observations method. See the in-line documentation of these two modules for further info observations : file : path : doc/observations/obs_example.tar.gz","title":"observations section:"},{"location":"settings/#optimize-section","text":"This section contains the keys that define the inversion problem. It contains two large subsection: one \"emissions\" subsection, which contains settings related to the state vector and its uncertainty matrix (structure of the uncertainty, number of optimized categories, resolution of the optimization, etc.) one \"observations\" subsection, which defines the way observation uncertainties are treated: optimize : emissions : co2 : biosphere : annual_uncertainty : 0.45 PgC spatial_correlation : 500-g temporal_correlation : 30D npoints : 2500 optimization_interval : 7d observations : co2 : uncertainty : type : dyn freq : 7d Here, the emissions will be optimized for the biosphere category of the co2 tracer. The total uncertainty is set to 0.45 PgC ( annual_uncertainty ), with correlations decaying spatially ( spatial_correlation ) following a 500 km Gaussian function, and temporally ( temporal_correlation ) following a 30 days exponential function (see sect 3.5.1 in https://gmd.copernicus.org/articles/14/3383/2021/ ). The inversion solves for 2500 cluster of pixels ( npoints ) each seven days ( optimization_interval ). With observations.co2.uncertainty.type set to dyn , the observation uncertainties are determined based on the quality of the fit of the short term (< 7 days) variability of the modelled concentration to the observed concentrations (see setup_uncertainties method).","title":"optimize section"},{"location":"settings/#congrad-section","text":"This short section contains settings for the conjugate gradient minimizer. The main relevant user-setting is max_number_of_iterations (set to a lower value to speed things up, set to > 50 for scientific results): congrad : max_number_of_iterations : 80 communication_file : ${run.paths.temp}/congrad.nc executable : ${lumia:src/congrad/congrad.exe}","title":"congrad section:"},{"location":"settings/#model-section","text":"This section contains settings for the interface between lumia and the transport model (i.e. lumia/obsoperator ) model : transport : exec : ${lumia:transport/multitracer.py} serial : False output : steps : ['apri', 'apos'] path : ${run.paths} Note the syntax of the model.transport.exec key: ${lumia:path} points to a path relative to the installation path of the lumia python module.","title":"model section"},{"location":"tutorial/","text":"Step-by-step inversion tutorial This tutorial shows how to run a simple CO2 inversion, using example data (download from the ICOS Carbon Portal ). This assumes that: LUMIA has been installed The example observation file (obs_example.tgz) and configuration file (inversion.yaml) are present in the current folder Footprint files are present on disk, in the ./footprints folder Pre-processed emission files are present in the ./data/fluxes/eurocom025x025/1h folder If the data is in a different place, edit the config file (inversion.yaml). The step-by-step procedure described below is the equivalent of just running lumia optim --rc inversion.yaml . Import modules # Modules required by the inversion from lumia import ui # user-interface (higher-level methods) from lumia.config import RcFile # Config files from lumia.formatters import xr # emission files from lumia.interfaces.multitracer import Interface # Interface betwen the model state (gridded fluxes) and the optimization (state vector) import lumia # Modules required for display purpose in this notebook: from IPython.display import display from matplotlib.pyplot import subplots import cartopy from numpy import log from numpy.random import randint Load the configuration file Detailed description of the config file can be found in the Settings section. rcf = RcFile('inversion.yaml') Load the observations file. The observation file contains two pandas dataframes: the observations DataFrame contains the observation themselves. Mandatory columns are time, site, height, obs, err_obs, mix_background, code and tracer: the sites DataFrame contains the information that is common to all obs of one site (lat, lon, alt, site name and site code). There not really any mandatory column ... In the observations table, the site column contains indices of the sites table (leftermost column in the output below), while the code column contains the site codes (they are similar in this instance, but site could be anything). height is the sampling height (above ground), while alt is the ground altitude (above sea level) at the sites. err_obs is the measurement uncertainty. Use a value below 0 if unavailable. obs = ui.load_observations(rcf) display(obs.observations) display(obs.sites) 2023-01-04 16:55:51.852 | INFO | lumia.obsdb:load_tar:169 - 71907 observation read from obs_example.tgz .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } time site height obs err_obs mix_background code tracer 0 2018-01-03 23:00:00 ssl 12.0 411.95 -9.990 410.626136 ssl co2 1 2018-01-04 00:00:00 ssl 12.0 412.03 -9.990 410.596810 ssl co2 2 2018-01-04 01:00:00 ssl 12.0 412.04 -9.990 410.560833 ssl co2 3 2018-01-04 02:00:00 ssl 12.0 411.59 -9.990 410.515688 ssl co2 4 2018-01-04 03:00:00 ssl 12.0 411.73 -9.990 410.463696 ssl co2 ... ... ... ... ... ... ... ... ... 71902 2018-08-28 12:00:00 gic 20.0 402.39 0.222 402.745598 gic co2 71903 2018-08-28 13:00:00 gic 20.0 402.42 0.285 402.983801 gic co2 71904 2018-08-28 14:00:00 gic 20.0 402.61 0.438 403.182289 gic co2 71905 2018-08-28 15:00:00 gic 20.0 403.19 0.248 403.303281 gic co2 71906 2018-08-29 11:00:00 gic 20.0 402.07 0.366 403.370067 gic co2 71907 rows \u00d7 8 columns .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name lat lon alt code bik Bialystok 53.231998 23.027000 183.0 bik bir Birkenes Observatory 58.388600 8.251900 219.0 bir bis Biscarrosse 44.378100 -1.231100 73.0 bis brm Beromunster 47.189600 8.175500 797.0 brm bsd Bilsdale 54.359000 -1.150000 380.0 bsd ces Cabauw 51.971000 4.927000 -1.0 ces cmn Monte Cimone 44.166668 10.683333 2165.0 cmn crp Carnsore Point 52.180000 -6.370000 9.0 crp dec Delta de l'Ebre 40.743900 0.786700 1.0 dec eec El Estrecho 36.058600 -5.664000 20.0 eec ers Ersa 42.969200 9.380100 533.0 ers fkl Finokalia 35.337800 25.669400 150.0 fkl gat Gartow 53.065700 11.442900 70.0 gat gic Sierra de Gredos 40.345700 -5.175500 1436.0 gic hei Heidelberg 49.417000 8.674000 116.0 hei hpb Hohenpeissenberg 47.801100 11.024600 934.0 hpb htm Hyltemossa 56.097600 13.418900 115.0 htm hun Hegyhatsal 46.950000 16.650000 248.0 hun ipr Ispra 45.814700 8.636000 210.0 ipr jfj Jungfraujoch 46.550000 7.987000 3570.0 jfj kas Kasprowy Wierch, High Tatra 49.232500 19.981800 1989.0 kas kre K\u0159e\u0161\u00edn u Pacova 49.572000 15.080000 534.0 kre lhw Laegern-Hochwacht 47.482200 8.397300 840.0 lhw lin Lindenberg 52.166300 14.122600 73.0 lin lmp Lampedusa 35.530000 12.520000 45.0 lmp lmu La Muela 41.594100 -1.100300 571.0 lmu lut Lutjewad 53.403600 6.352800 1.0 lut mhd Mace Head 53.326100 -9.903600 5.0 mhd mlh Malin Head 55.355000 -7.333000 22.0 mlh nor Norunda 60.086400 17.479400 46.0 nor ohp Observatoire de Haute Provence 43.931000 5.712000 650.0 ohp ope Observatoire p\u00e9renne de l'environnement 48.561900 5.503600 390.0 ope pal Pallas-Sammaltunturi, GAW Station 67.973300 24.115700 565.0 pal pdm Pic du Midi 42.937200 0.141100 2877.0 pdm prs Plateau Rosa Station 45.930000 7.700000 3480.0 prs pui Puijo 62.909600 27.654900 232.0 pui puy Puy de D\u00f4me 45.771900 2.965800 1465.0 puy rgl Ridge Hill 51.997600 -2.540000 204.0 rgl sac Saclay 48.722700 2.142000 160.0 sac smr Hyyti\u00e4l\u00e4 61.847400 24.294700 181.0 smr ssl Schauinsland, Baden-Wuerttemberg 47.920000 7.920000 1205.0 ssl svb Svartberget 64.256000 19.775000 235.0 svb tac Tacolneston 52.517700 1.138600 56.0 tac trn Trainou 47.964700 2.112500 131.0 trn uto Ut\u00f6 - Baltic sea 59.783900 21.367200 8.0 uto wao Weybourne, Norfolk 52.950200 1.121900 20.0 wao Construct the emission file LUMIA requires all the emissions to be in a netCDF4 file, covering the entire inversion period. The file can be generated from pre-processed annual, category-specific emission files. The emission file for the simulation is constructed based on keys in the emissions section of the configuration file: in our case, there is a single co2 tracer the pre-processed emission files start with the prefix \" flux_co2. \" ( emissions.co2.prefix key) there are two categories under the emissions.co2.categories section: fossil (EDGARv4.3_BP2019) biosphere (VPRM) fluxes are hourly ( emissions.co2.interval ) and in the path given by emissions.co2.path Therefore, lumia will take biosphere fluxes from the flux_co2.VPRM.%Y.nc files, and fossil emissions from the flux_co2.EDGARv4.3_BP2019.%Y.nc files. The fluxes will be located in the folder ${emissions.co2.path}/${emissions.co2.interval} (i.e. data/fluxes/nc/eurocom025x025/1h ). The emissions can be constructed using the ui.prepare_emis method. Check that the values it prints are realistic! emis = ui.prepare_emis(rcf) 2023-01-03 21:52:19.670 | INFO | lumia.formatters.xr:print_summary:287 - =============================== 2023-01-03 21:52:19.681 | INFO | lumia.formatters.xr:print_summary:288 - fossil: 2023-01-03 21:52:19.686 | INFO | lumia.formatters.xr:print_summary:290 - 2018: 2023-01-03 21:52:19.692 | INFO | lumia.formatters.xr:print_summary:293 - January: 0.15 petagC 2023-01-03 21:52:19.694 | INFO | lumia.formatters.xr:print_summary:293 - February: 0.13 petagC 2023-01-03 21:52:19.696 | INFO | lumia.formatters.xr:print_summary:293 - March: 0.14 petagC 2023-01-03 21:52:19.698 | INFO | lumia.formatters.xr:print_summary:293 - April: 0.12 petagC 2023-01-03 21:52:19.699 | INFO | lumia.formatters.xr:print_summary:293 - May: 0.12 petagC 2023-01-03 21:52:19.700 | INFO | lumia.formatters.xr:print_summary:293 - June: 0.10 petagC 2023-01-03 21:52:19.701 | INFO | lumia.formatters.xr:print_summary:293 - July: 0.10 petagC 2023-01-03 21:52:19.704 | INFO | lumia.formatters.xr:print_summary:293 - August: 0.11 petagC 2023-01-03 21:52:19.705 | INFO | lumia.formatters.xr:print_summary:293 - September: 0.11 petagC 2023-01-03 21:52:19.706 | INFO | lumia.formatters.xr:print_summary:293 - October: 0.13 petagC 2023-01-03 21:52:19.708 | INFO | lumia.formatters.xr:print_summary:293 - November: 0.13 petagC 2023-01-03 21:52:19.710 | INFO | lumia.formatters.xr:print_summary:293 - December: 0.14 petagC 2023-01-03 21:52:19.711 | INFO | lumia.formatters.xr:print_summary:294 - -------------------------- 2023-01-03 21:52:19.711 | INFO | lumia.formatters.xr:print_summary:295 - Total : 1.48 petagC 2023-01-03 21:52:20.535 | INFO | lumia.formatters.xr:print_summary:287 - =============================== 2023-01-03 21:52:20.537 | INFO | lumia.formatters.xr:print_summary:288 - biosphere: 2023-01-03 21:52:20.539 | INFO | lumia.formatters.xr:print_summary:290 - 2018: 2023-01-03 21:52:20.541 | INFO | lumia.formatters.xr:print_summary:293 - January: 0.12 petagC 2023-01-03 21:52:20.542 | INFO | lumia.formatters.xr:print_summary:293 - February: 0.09 petagC 2023-01-03 21:52:20.543 | INFO | lumia.formatters.xr:print_summary:293 - March: 0.07 petagC 2023-01-03 21:52:20.545 | INFO | lumia.formatters.xr:print_summary:293 - April: -0.18 petagC 2023-01-03 21:52:20.547 | INFO | lumia.formatters.xr:print_summary:293 - May: -0.61 petagC 2023-01-03 21:52:20.548 | INFO | lumia.formatters.xr:print_summary:293 - June: -0.60 petagC 2023-01-03 21:52:20.550 | INFO | lumia.formatters.xr:print_summary:293 - July: -0.45 petagC 2023-01-03 21:52:20.551 | INFO | lumia.formatters.xr:print_summary:293 - August: -0.23 petagC 2023-01-03 21:52:20.553 | INFO | lumia.formatters.xr:print_summary:293 - September: -0.03 petagC 2023-01-03 21:52:20.554 | INFO | lumia.formatters.xr:print_summary:293 - October: 0.11 petagC 2023-01-03 21:52:20.556 | INFO | lumia.formatters.xr:print_summary:293 - November: 0.12 petagC 2023-01-03 21:52:20.557 | INFO | lumia.formatters.xr:print_summary:293 - December: 0.11 petagC 2023-01-03 21:52:20.558 | INFO | lumia.formatters.xr:print_summary:294 - -------------------------- 2023-01-03 21:52:20.559 | INFO | lumia.formatters.xr:print_summary:295 - Total : -1.49 petagC Setup the transport model The lumia.transport class handles the communication between lumia and the (pseudo-) transport model. The \"formatter\" is a module containing a WriteStruct and a ReadStruct functions, whose task is to write/read data drivers data for the transport model (and output data of its adjoint). model = lumia.transport(rcf, obs=obs, formatter=xr) Setup the observation uncertainties. In this example, we use the dyn approach. The obs uncertainty (which accounts for model error) is estimated based on the quality of the fit to the short-term observed variability. This works the following way: 1. A forward model run is performed, with prior emissions 2. long-term variability (> 7 days) is removed from both the modelled and the observed concentrations (this is done by subtracting their 7-days moving average) 3. the obs uncertainty is the standard deviation of the fit of the modelled detrended concentrations to the observed ones. The rationale is that, since the inversion only optimize emissions at a weekly interval (in this example), shorter variability cannot be improved and is therefore necessarily a feature of the model uncertainty. Note that this technique requires performing a forward model run. Other approaches are implemented but haven't necessarily been updated to the yaml config file, so adjustments in the code might be needed (in the obsdb/InversionDb.py file) model = ui.setup_uncertainties(model, emis) The plots below illustrate the calculation and comparison of short-term variability at one example site: dbs = model.db['bik'] f, ax = subplots(2, 1, figsize=(16, 8)) ax[0].plot(dbs.time, dbs.obs, 'k.', label='obs', ms=1) ax[0].plot(dbs.time, dbs.obs_detrended, 'k-', label='obs detrended') ax[0].plot(dbs.time, dbs.mix_apri, 'r.', label='apri', ms=1) ax[0].plot(dbs.time, dbs.mod_detrended, 'r-', label='apri detrended') ax[0].grid() ax[0].legend() ax[0].set_title('concentrations at Byalistok') ax[1].plot(dbs.time, dbs.resid_obs, 'k-', label='short term variability obs') ax[1].plot(dbs.time, dbs.resid_mod, 'r-', label='short term variability model') ax[1].grid() ax[1].legend() sig = (dbs.resid_mod - dbs.resid_obs).std() ax[1].set_title(f'Short-term variability of the concentration at Byalistok (sigma = {sig:.2f} ppm)') Text(0.5, 1.0, 'Short-term variability of the concentration at Byalistok (sigma = 3.99 ppm)') Definition of the state vector The inversion adjusts 2500 pixels or cluster of pixels every week (or whatever values set by the optimize.emissions.co2.*.npoints and optimize.emissions.co2.*.optimization_interval keys). The grouping of pixels in clusters is based on the sensitivity of the observation network to the emissions: pixels not well monitored by the observation network will tend to be grouped together, while pixels directly upwind of the measurement stations will be optimized independently. This clustering is calculated dynamically, based on an initial adjoint run: sensi = model.calcSensitivityMap(emis) Below the Interface is the module that handles the transitions between optimization space (state vector, 2500 x n_weeks points x n_tracers x n_cat) and the model space (gridded fluxes). control = Interface(model.rcf, model_data=emis, sensi_map=sensi) The plots below illustrate the calculated sensitivity of the observation network to the surface fluxes (left panel), and the resulting clustering of emissions (right panel, the colors are random). Note that there are only footprints for two sites in the example data used to generate this notebook. In a more realistic case, the maps would look somewhat different ... f, ax = subplots(1, 2, figsize=(16, 8), subplot_kw=dict(projection=cartopy.crs.PlateCarree(), extent=rcf['run']['grid'].extent)) ax[0].coastlines() ax[0].imshow(log(sensi['co2']), extent=rcf['run']['grid'].extent, origin='lower') ax[0].set_title(\"sensitivity of the network to the fluxes (log scale)\") smap = control.model_data.co2.spatial_mapping['biosphere'].values.copy() for ii in range(smap.shape[1]): smap[smap[:, ii] != 0, ii] = randint(0, 1000) ax[1].imshow(smap.sum(1).reshape((160, 200)), origin='lower', extent=rcf['run']['grid'].extent) ax[1].coastlines() ax[1].set_title('Optimized clusters') Text(0.5, 1.0, 'Optimized clusters') Run the inversion The prior error-covariance matrix will be calculated when initializing the optimizer (first line below). opt = lumia.optimizer.Optimizer(model.rcf, model, control) opt.Var4D()","title":"Tutorial"},{"location":"tutorial/#step-by-step-inversion-tutorial","text":"This tutorial shows how to run a simple CO2 inversion, using example data (download from the ICOS Carbon Portal ). This assumes that: LUMIA has been installed The example observation file (obs_example.tgz) and configuration file (inversion.yaml) are present in the current folder Footprint files are present on disk, in the ./footprints folder Pre-processed emission files are present in the ./data/fluxes/eurocom025x025/1h folder If the data is in a different place, edit the config file (inversion.yaml). The step-by-step procedure described below is the equivalent of just running lumia optim --rc inversion.yaml .","title":"Step-by-step inversion tutorial"},{"location":"tutorial/#import-modules","text":"# Modules required by the inversion from lumia import ui # user-interface (higher-level methods) from lumia.config import RcFile # Config files from lumia.formatters import xr # emission files from lumia.interfaces.multitracer import Interface # Interface betwen the model state (gridded fluxes) and the optimization (state vector) import lumia # Modules required for display purpose in this notebook: from IPython.display import display from matplotlib.pyplot import subplots import cartopy from numpy import log from numpy.random import randint","title":"Import modules"},{"location":"tutorial/#load-the-configuration-file","text":"Detailed description of the config file can be found in the Settings section. rcf = RcFile('inversion.yaml')","title":"Load the configuration file"},{"location":"tutorial/#load-the-observations-file","text":"The observation file contains two pandas dataframes: the observations DataFrame contains the observation themselves. Mandatory columns are time, site, height, obs, err_obs, mix_background, code and tracer: the sites DataFrame contains the information that is common to all obs of one site (lat, lon, alt, site name and site code). There not really any mandatory column ... In the observations table, the site column contains indices of the sites table (leftermost column in the output below), while the code column contains the site codes (they are similar in this instance, but site could be anything). height is the sampling height (above ground), while alt is the ground altitude (above sea level) at the sites. err_obs is the measurement uncertainty. Use a value below 0 if unavailable. obs = ui.load_observations(rcf) display(obs.observations) display(obs.sites) 2023-01-04 16:55:51.852 | INFO | lumia.obsdb:load_tar:169 - 71907 observation read from obs_example.tgz .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } time site height obs err_obs mix_background code tracer 0 2018-01-03 23:00:00 ssl 12.0 411.95 -9.990 410.626136 ssl co2 1 2018-01-04 00:00:00 ssl 12.0 412.03 -9.990 410.596810 ssl co2 2 2018-01-04 01:00:00 ssl 12.0 412.04 -9.990 410.560833 ssl co2 3 2018-01-04 02:00:00 ssl 12.0 411.59 -9.990 410.515688 ssl co2 4 2018-01-04 03:00:00 ssl 12.0 411.73 -9.990 410.463696 ssl co2 ... ... ... ... ... ... ... ... ... 71902 2018-08-28 12:00:00 gic 20.0 402.39 0.222 402.745598 gic co2 71903 2018-08-28 13:00:00 gic 20.0 402.42 0.285 402.983801 gic co2 71904 2018-08-28 14:00:00 gic 20.0 402.61 0.438 403.182289 gic co2 71905 2018-08-28 15:00:00 gic 20.0 403.19 0.248 403.303281 gic co2 71906 2018-08-29 11:00:00 gic 20.0 402.07 0.366 403.370067 gic co2 71907 rows \u00d7 8 columns .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name lat lon alt code bik Bialystok 53.231998 23.027000 183.0 bik bir Birkenes Observatory 58.388600 8.251900 219.0 bir bis Biscarrosse 44.378100 -1.231100 73.0 bis brm Beromunster 47.189600 8.175500 797.0 brm bsd Bilsdale 54.359000 -1.150000 380.0 bsd ces Cabauw 51.971000 4.927000 -1.0 ces cmn Monte Cimone 44.166668 10.683333 2165.0 cmn crp Carnsore Point 52.180000 -6.370000 9.0 crp dec Delta de l'Ebre 40.743900 0.786700 1.0 dec eec El Estrecho 36.058600 -5.664000 20.0 eec ers Ersa 42.969200 9.380100 533.0 ers fkl Finokalia 35.337800 25.669400 150.0 fkl gat Gartow 53.065700 11.442900 70.0 gat gic Sierra de Gredos 40.345700 -5.175500 1436.0 gic hei Heidelberg 49.417000 8.674000 116.0 hei hpb Hohenpeissenberg 47.801100 11.024600 934.0 hpb htm Hyltemossa 56.097600 13.418900 115.0 htm hun Hegyhatsal 46.950000 16.650000 248.0 hun ipr Ispra 45.814700 8.636000 210.0 ipr jfj Jungfraujoch 46.550000 7.987000 3570.0 jfj kas Kasprowy Wierch, High Tatra 49.232500 19.981800 1989.0 kas kre K\u0159e\u0161\u00edn u Pacova 49.572000 15.080000 534.0 kre lhw Laegern-Hochwacht 47.482200 8.397300 840.0 lhw lin Lindenberg 52.166300 14.122600 73.0 lin lmp Lampedusa 35.530000 12.520000 45.0 lmp lmu La Muela 41.594100 -1.100300 571.0 lmu lut Lutjewad 53.403600 6.352800 1.0 lut mhd Mace Head 53.326100 -9.903600 5.0 mhd mlh Malin Head 55.355000 -7.333000 22.0 mlh nor Norunda 60.086400 17.479400 46.0 nor ohp Observatoire de Haute Provence 43.931000 5.712000 650.0 ohp ope Observatoire p\u00e9renne de l'environnement 48.561900 5.503600 390.0 ope pal Pallas-Sammaltunturi, GAW Station 67.973300 24.115700 565.0 pal pdm Pic du Midi 42.937200 0.141100 2877.0 pdm prs Plateau Rosa Station 45.930000 7.700000 3480.0 prs pui Puijo 62.909600 27.654900 232.0 pui puy Puy de D\u00f4me 45.771900 2.965800 1465.0 puy rgl Ridge Hill 51.997600 -2.540000 204.0 rgl sac Saclay 48.722700 2.142000 160.0 sac smr Hyyti\u00e4l\u00e4 61.847400 24.294700 181.0 smr ssl Schauinsland, Baden-Wuerttemberg 47.920000 7.920000 1205.0 ssl svb Svartberget 64.256000 19.775000 235.0 svb tac Tacolneston 52.517700 1.138600 56.0 tac trn Trainou 47.964700 2.112500 131.0 trn uto Ut\u00f6 - Baltic sea 59.783900 21.367200 8.0 uto wao Weybourne, Norfolk 52.950200 1.121900 20.0 wao","title":"Load the observations file."},{"location":"tutorial/#construct-the-emission-file","text":"LUMIA requires all the emissions to be in a netCDF4 file, covering the entire inversion period. The file can be generated from pre-processed annual, category-specific emission files. The emission file for the simulation is constructed based on keys in the emissions section of the configuration file: in our case, there is a single co2 tracer the pre-processed emission files start with the prefix \" flux_co2. \" ( emissions.co2.prefix key) there are two categories under the emissions.co2.categories section: fossil (EDGARv4.3_BP2019) biosphere (VPRM) fluxes are hourly ( emissions.co2.interval ) and in the path given by emissions.co2.path Therefore, lumia will take biosphere fluxes from the flux_co2.VPRM.%Y.nc files, and fossil emissions from the flux_co2.EDGARv4.3_BP2019.%Y.nc files. The fluxes will be located in the folder ${emissions.co2.path}/${emissions.co2.interval} (i.e. data/fluxes/nc/eurocom025x025/1h ). The emissions can be constructed using the ui.prepare_emis method. Check that the values it prints are realistic! emis = ui.prepare_emis(rcf) 2023-01-03 21:52:19.670 | INFO | lumia.formatters.xr:print_summary:287 - =============================== 2023-01-03 21:52:19.681 | INFO | lumia.formatters.xr:print_summary:288 - fossil: 2023-01-03 21:52:19.686 | INFO | lumia.formatters.xr:print_summary:290 - 2018: 2023-01-03 21:52:19.692 | INFO | lumia.formatters.xr:print_summary:293 - January: 0.15 petagC 2023-01-03 21:52:19.694 | INFO | lumia.formatters.xr:print_summary:293 - February: 0.13 petagC 2023-01-03 21:52:19.696 | INFO | lumia.formatters.xr:print_summary:293 - March: 0.14 petagC 2023-01-03 21:52:19.698 | INFO | lumia.formatters.xr:print_summary:293 - April: 0.12 petagC 2023-01-03 21:52:19.699 | INFO | lumia.formatters.xr:print_summary:293 - May: 0.12 petagC 2023-01-03 21:52:19.700 | INFO | lumia.formatters.xr:print_summary:293 - June: 0.10 petagC 2023-01-03 21:52:19.701 | INFO | lumia.formatters.xr:print_summary:293 - July: 0.10 petagC 2023-01-03 21:52:19.704 | INFO | lumia.formatters.xr:print_summary:293 - August: 0.11 petagC 2023-01-03 21:52:19.705 | INFO | lumia.formatters.xr:print_summary:293 - September: 0.11 petagC 2023-01-03 21:52:19.706 | INFO | lumia.formatters.xr:print_summary:293 - October: 0.13 petagC 2023-01-03 21:52:19.708 | INFO | lumia.formatters.xr:print_summary:293 - November: 0.13 petagC 2023-01-03 21:52:19.710 | INFO | lumia.formatters.xr:print_summary:293 - December: 0.14 petagC 2023-01-03 21:52:19.711 | INFO | lumia.formatters.xr:print_summary:294 - -------------------------- 2023-01-03 21:52:19.711 | INFO | lumia.formatters.xr:print_summary:295 - Total : 1.48 petagC 2023-01-03 21:52:20.535 | INFO | lumia.formatters.xr:print_summary:287 - =============================== 2023-01-03 21:52:20.537 | INFO | lumia.formatters.xr:print_summary:288 - biosphere: 2023-01-03 21:52:20.539 | INFO | lumia.formatters.xr:print_summary:290 - 2018: 2023-01-03 21:52:20.541 | INFO | lumia.formatters.xr:print_summary:293 - January: 0.12 petagC 2023-01-03 21:52:20.542 | INFO | lumia.formatters.xr:print_summary:293 - February: 0.09 petagC 2023-01-03 21:52:20.543 | INFO | lumia.formatters.xr:print_summary:293 - March: 0.07 petagC 2023-01-03 21:52:20.545 | INFO | lumia.formatters.xr:print_summary:293 - April: -0.18 petagC 2023-01-03 21:52:20.547 | INFO | lumia.formatters.xr:print_summary:293 - May: -0.61 petagC 2023-01-03 21:52:20.548 | INFO | lumia.formatters.xr:print_summary:293 - June: -0.60 petagC 2023-01-03 21:52:20.550 | INFO | lumia.formatters.xr:print_summary:293 - July: -0.45 petagC 2023-01-03 21:52:20.551 | INFO | lumia.formatters.xr:print_summary:293 - August: -0.23 petagC 2023-01-03 21:52:20.553 | INFO | lumia.formatters.xr:print_summary:293 - September: -0.03 petagC 2023-01-03 21:52:20.554 | INFO | lumia.formatters.xr:print_summary:293 - October: 0.11 petagC 2023-01-03 21:52:20.556 | INFO | lumia.formatters.xr:print_summary:293 - November: 0.12 petagC 2023-01-03 21:52:20.557 | INFO | lumia.formatters.xr:print_summary:293 - December: 0.11 petagC 2023-01-03 21:52:20.558 | INFO | lumia.formatters.xr:print_summary:294 - -------------------------- 2023-01-03 21:52:20.559 | INFO | lumia.formatters.xr:print_summary:295 - Total : -1.49 petagC","title":"Construct the emission file"},{"location":"tutorial/#setup-the-transport-model","text":"The lumia.transport class handles the communication between lumia and the (pseudo-) transport model. The \"formatter\" is a module containing a WriteStruct and a ReadStruct functions, whose task is to write/read data drivers data for the transport model (and output data of its adjoint). model = lumia.transport(rcf, obs=obs, formatter=xr)","title":"Setup the transport model"},{"location":"tutorial/#setup-the-observation-uncertainties","text":"In this example, we use the dyn approach. The obs uncertainty (which accounts for model error) is estimated based on the quality of the fit to the short-term observed variability. This works the following way: 1. A forward model run is performed, with prior emissions 2. long-term variability (> 7 days) is removed from both the modelled and the observed concentrations (this is done by subtracting their 7-days moving average) 3. the obs uncertainty is the standard deviation of the fit of the modelled detrended concentrations to the observed ones. The rationale is that, since the inversion only optimize emissions at a weekly interval (in this example), shorter variability cannot be improved and is therefore necessarily a feature of the model uncertainty. Note that this technique requires performing a forward model run. Other approaches are implemented but haven't necessarily been updated to the yaml config file, so adjustments in the code might be needed (in the obsdb/InversionDb.py file) model = ui.setup_uncertainties(model, emis) The plots below illustrate the calculation and comparison of short-term variability at one example site: dbs = model.db['bik'] f, ax = subplots(2, 1, figsize=(16, 8)) ax[0].plot(dbs.time, dbs.obs, 'k.', label='obs', ms=1) ax[0].plot(dbs.time, dbs.obs_detrended, 'k-', label='obs detrended') ax[0].plot(dbs.time, dbs.mix_apri, 'r.', label='apri', ms=1) ax[0].plot(dbs.time, dbs.mod_detrended, 'r-', label='apri detrended') ax[0].grid() ax[0].legend() ax[0].set_title('concentrations at Byalistok') ax[1].plot(dbs.time, dbs.resid_obs, 'k-', label='short term variability obs') ax[1].plot(dbs.time, dbs.resid_mod, 'r-', label='short term variability model') ax[1].grid() ax[1].legend() sig = (dbs.resid_mod - dbs.resid_obs).std() ax[1].set_title(f'Short-term variability of the concentration at Byalistok (sigma = {sig:.2f} ppm)') Text(0.5, 1.0, 'Short-term variability of the concentration at Byalistok (sigma = 3.99 ppm)')","title":"Setup the observation uncertainties."},{"location":"tutorial/#definition-of-the-state-vector","text":"The inversion adjusts 2500 pixels or cluster of pixels every week (or whatever values set by the optimize.emissions.co2.*.npoints and optimize.emissions.co2.*.optimization_interval keys). The grouping of pixels in clusters is based on the sensitivity of the observation network to the emissions: pixels not well monitored by the observation network will tend to be grouped together, while pixels directly upwind of the measurement stations will be optimized independently. This clustering is calculated dynamically, based on an initial adjoint run: sensi = model.calcSensitivityMap(emis) Below the Interface is the module that handles the transitions between optimization space (state vector, 2500 x n_weeks points x n_tracers x n_cat) and the model space (gridded fluxes). control = Interface(model.rcf, model_data=emis, sensi_map=sensi) The plots below illustrate the calculated sensitivity of the observation network to the surface fluxes (left panel), and the resulting clustering of emissions (right panel, the colors are random). Note that there are only footprints for two sites in the example data used to generate this notebook. In a more realistic case, the maps would look somewhat different ... f, ax = subplots(1, 2, figsize=(16, 8), subplot_kw=dict(projection=cartopy.crs.PlateCarree(), extent=rcf['run']['grid'].extent)) ax[0].coastlines() ax[0].imshow(log(sensi['co2']), extent=rcf['run']['grid'].extent, origin='lower') ax[0].set_title(\"sensitivity of the network to the fluxes (log scale)\") smap = control.model_data.co2.spatial_mapping['biosphere'].values.copy() for ii in range(smap.shape[1]): smap[smap[:, ii] != 0, ii] = randint(0, 1000) ax[1].imshow(smap.sum(1).reshape((160, 200)), origin='lower', extent=rcf['run']['grid'].extent) ax[1].coastlines() ax[1].set_title('Optimized clusters') Text(0.5, 1.0, 'Optimized clusters')","title":"Definition of the state vector"},{"location":"tutorial/#run-the-inversion","text":"The prior error-covariance matrix will be calculated when initializing the optimizer (first line below). opt = lumia.optimizer.Optimizer(model.rcf, model, control) opt.Var4D()","title":"Run the inversion"}]}