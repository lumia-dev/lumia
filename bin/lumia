#!/usr/bin/env python3

import sys
from argparse import ArgumentParser
from loguru import logger
import subprocess
from typing import List
from pathlib import Path
import lumia
from configparser import ConfigParser
from lumia.main_functions import prepare, run, test


def apptainer_wrapper(args: List):
    """
    Determine if the main script should be run in an apptainer container. If so, resubmit the command within the requested container, otherwise just continue.

    """
    # Load defaults:
    parser = ArgumentParser(args, add_help=False)
    parser.add_argument('--app', action='store_true', default=False)
    parser.add_argument('--footprints', default=None)
    parser.add_argument('--output', '-o', default=None)
    parser.add_argument('--scratch', default=None)
    parser.add_argument('--bind', '-b', action='append')
    parser.add_argument('--container', default=None)
    parser.add_argument('--dev', action='store_true', default=False, help='Use a dev container and mount the lumia source code under /lumia')
    parser.add_argument('--app-config', dest='settings', default=Path('lumia.ini'), help='Location of the file containing the container default settings. If no value is provided, the code will look for "lumia.ini" in the current directory, then for "lumia.ini" in the ~/.config folder.', type=Path)

    args, remainder = parser.parse_known_args()

    if args.app:
        # Read default settings from various config files. Each file overwrites the previous one
        # (so one can be viewed as a machine settings, the next one a project settings, etc.)
        # Not all files are expected to be present, so no error is raised if one or more files are missing.

        conf = ConfigParser()
        conf.read(Path.home() / '.config/lumia.ini') # Read from ~/.config
        conf.read(lumia.prefix / 'etc/lumia.ini')    # Read from the path where the lumia python library is installed
        conf.read(args.settings)                     # Read from the path provided as argument (default: current path)

        # handle the "--dev" flag:
        if args.dev :
            conf['container']['active'] = conf['container']['dev']
            conf['bind']['/lumia'] = str(lumia.prefix)
        else:
            conf['container']['active'] = conf['container']['default']

        # Next, overwrite with script arguments
        if args.footprints is not None:
            conf['bind']['/footprints'] = args.footprints
        if args.output is not None:
            conf['bind']['/output'] = args.output
        if args.bind is not None:
            conf['bind']['/scratch'] = args.scratch
        if args.container is not None:
            conf['container']['active'] = args.container

        if args.bind is not None:
            for b in args.bind:
                dest, src = b.split(':')
                conf['bind'][dest] = src

        # Construct the command line:
        cmd = 'apptainer run --cleanenv'
        for dest, src in conf['bind'].items() :
            cmd += f' --bind {src}:{dest}'
        cmd += ' '+conf['container']['active']

        # Ensure that the three mandatory paths exist:
        Path(conf['bind']['/output']).mkdir(exist_ok=True)
        Path(conf['bind']['/scratch']).mkdir(exist_ok=True)
        Path(conf['bind']['/data']).mkdir(exist_ok=True)

        if '--help' in remainder or '-h' in remainder:
            parser.print_help()
            sys.exit()

        cmd += ' '+' '.join([_ for _ in remainder])
        logger.info(cmd)
        subprocess.run(cmd.split())
        sys.exit()

    else :
        return remainder


if __name__ == '__main__':

    p = ArgumentParser()
    p.add_argument('--rcf', type=Path, help='Path to the configuration file (rc-file)')
    p.add_argument('--app', action='store_true', default=False, help='Run the simulation in an apptainer container (call "lumia --container --help" for dedicated help message)') # This does nothing, except adding the relevant help message.
    p.add_argument('--verbosity', '-v', default='INFO')
    p.add_argument('action', choices=['forward', 'optim', 'adjtest', 'gradtest', 'emis', 'adjtestmod', 'validate'], help='What to do')
    p.add_argument('--fakeobs', action='store_true', help='Run the model at the time of existing footprints instead of on the basis of an observation file')
    p.add_argument('--start', help='Start of the simulation (overwrites the "time.start" rc-key')
    p.add_argument('--end', help='End of the simulation (overwrites the "time.end" rc-key')
    p.add_argument('--tag', default='', help='suffix appended to the output path (default is based on the start and end time of the simulation')
    p.add_argument('--setkey', action='append', help='Overwrites the value of one rc-key. This can be used multiple times. For instance, "lumia forward --rcf config.rcf --setkey obs.file:file.tar.gz --setkey --setkey emissions.co2.interval:1H" will set the "obs.file" key to "file.tar.gz", and "emissions.*.interval" to "1H" (regardless of whatever settings were given before)')

    args = apptainer_wrapper(sys.argv[1:])
    args = p.parse_args(args)

    # Most basic case: just run lumia
    logger.remove()
    logger.add(sys.stderr, level=args.verbosity)

    logger.info(args)

    # Read and append configuration file
    rcf = prepare.config(args)

    # Ensure that the relevant paths exist
    prepare.paths(rcf)

    match args.action:
        case 'forward':
            results = run.forward(rcf)

        case 'optim':
            results = run.optimize(rcf)

        case 'adjtest':
            results = test.adjoint(rcf)

        case 'adjtestmod':
            results = test.model_adjoint(rcf)

        case 'gradtest':
            results = test.gradient(rcf)

        case 'emis':
            emis = prepare.emissions(rcf)

        case 'validate':
            results = run.validate(rcf)
